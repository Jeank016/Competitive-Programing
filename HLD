#include <bits/stdc++.h>
 
#define forn(i,n) for (int i = 0; i < n; i++)
#define rforn(i,n) for (int i = n-1; i >= 0; i--)
#define fornP(i,a,b) for (int i = a; i  < b; i++)
#define endl '\n'
#define ff first
#define ss second   
#define pb push_back
#define ll long long
#define all(x) x.begin(),x.end()
#define sz(n) (int)n.size()
#define read(x) for(auto &el : x) cin >> el;
#define show(x) for (auto &i: x) cout << i << " "; cout << "\n";
#define FAST ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0);
 
using namespace std;
 
 
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
template<class T> using T_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
template<class L> using T_multiset = tree<L, null_type, less_equal<L>, rb_tree_tag, tree_order_statistics_node_update>;
 
const double pi = 3.141592653589793;

template<typename T>
struct STree {
    int n; vector<T> st, lazy;
    T neutro = T(0);

    STree(int m) {
        n = m;
        st.resize(n * 4);
        lazy.resize(n * 4);
    }

    STree(vector<T> &a) {
        n = sz(a);
        st.resize(n * 4);
        lazy.resize(n * 4);
        build(1, 0, n - 1, a);
    }

    T oper(T a, T b) { return a + b; }

    void build(int v, int tl, int tr, vector<T> &a) {
        if(tl == tr) {
        st[v] = a[tl];
        return;
        }
        int tm = (tl + tr) / 2;
        build(v * 2, tl, tm, a);
        build(v * 2 + 1, tm + 1, tr, a);
        st[v] = oper(st[v * 2], st[v * 2 + 1]);
    }

    void push(int v, int tl, int tr) {
        if (!lazy[v]) return;
        st[v] += (tr - tl + 1) * lazy[v];
        if (tl != tr) {
        lazy[v * 2] += lazy[v];
        lazy[v * 2 + 1] += lazy[v];
        }
        lazy[v] = 0;
    }

    void upd(int v, int tl, int tr, int l, int r, T val) {
        push(v, tl, tr);
        if(tr < l || tl > r) return;
        if (tl >= l && tr <= r) {
        lazy[v] = val;
        push(v, tl, tr);
        return;
        }
        int tm = (tl + tr) / 2;
        upd(v * 2, tl, tm, l, r, val);
        upd(v * 2 + 1, tm + 1, tr, l, r, val);
        st[v] = oper(st[v * 2], st[v * 2 + 1]);
    }

    T query(int v, int tl, int tr, int l, int r) {
        push(v, tl, tr);
        if(tl > r || tr < l) return neutro;
        if (l <= tl && tr <= r) return st[v];
        int tm = (tl + tr) / 2;
        return oper(query(v * 2, tl, tm, l, r), query(v * 2 + 1, tm + 1, tr, l, r));
    }

    void upd(int l, int r, T val) { upd(1, 0, n - 1, l, r, val); }
    T query(int l, int r) { return query(1, 0, n - 1, l, r); }
};

vector < vector <int> > g,aux;
vector <int> pre, res;
vector <bool> vis;


void oka(int n){
    pre.resize(n);
    pre[0] = 0;
    g.resize(n);    
    res.resize(n,0);
    vis.resize(n,0);
    aux.resize(n);
}

struct HLD {
    int n, timer;
    vector<int> in, out, nxt, tam;
    
    HLD(int v, int n) {
        this->n = n;
        timer = 0;
        in.resize(n);
        out.resize(n);
        nxt.resize(n);
        tam.resize(n);
        dfs_sz(v);
        nxt[v] = v;
        dfs_hld(v);
    }
    
    void dfs_sz(int v) {
        tam[v] = 1;
        for (auto &u : g[v]) {
            dfs_sz(u);
            tam[v] += tam[u];
            if (tam[u] > tam[g[v][0]])
                swap(u, g[v][0]);
        }
    }
    
    void dfs_hld(int v) {
        //res.pb(v);
        in[v] = timer++;
        for (auto &u : g[v]) {
            nxt[u] = u == g[v][0] ? nxt[v] : u;
            dfs_hld(u);
        }
        out[v] = timer;
    }

    void path(int a, int b, STree <int> &st, int oper){        
        int l = 0, r = 0;
        while (nxt[a] != nxt[b]){
            if (in[a] < in[b]){                                
                l = in[nxt[b]], r = in[b];
                if (oper == 1) st.upd(l,r,1);                
                else st.upd(l,r,-1);
                b = pre[nxt[b]];
            }else{
                l = in[nxt[a]], r = in[a];
                if (oper == 1) st.upd(l,r,1);            
                else st.upd(l,r,-1);
                a = pre[nxt[a]];
            }            
        }
        l = in[a], r = in[b];
        if (l > r) swap(l,r);        
        if (oper == 1) st.upd(l,r,1);            
        else st.upd(l,r,-1);        
    }

    int count(int a, int b, STree <int> &st){
        int ans = 0;
        int l = 0, r = 0;
        int x = 0;
        while (nxt[a] != nxt[b]){
            if (in[a] < in[b]){                                
                l = in[nxt[b]], r = in[b];                
                x = st.query(l,r);
                ans += x - (r - l + 1);                     
                b = pre[nxt[b]];
            }else{
                l = in[nxt[a]], r = in[a];
                x = st.query(l,r);
                ans += x -(r - l + 1);                     
                a = pre[nxt[a]];
            }            
        }
        l = in[a], r = in[b];
        if (l > r) swap(l,r);
        x = st.query(l,r);
        ans += x - (r - l + 1);                     
        return ans;
    }

    void clear(){

    }
};

void newG (int u){
    vis[u] = true;
    for (auto v: g[u]){
        if (vis[v] == false){
            aux[u].pb(v);
            pre[v] = u;
            newG(v);
        }
    }
}
void solve (){

    int n,q; cin >> n >> q;
    oka(n);
    forn(i,n-1){
        int u,v; cin >> u >> v;
        u--,v--;
        g[u].pb(v);
        g[v].pb(u);
        pre[v] = u;
    }
    newG(0);
    g = aux;
    // Armar el HLD
    HLD tree(0,n);    
    STree<int> st(res);


    while (q--){
        int a,b,c,d; cin >> a >> b >> c >> d;
        a--,b--,c--,d--;        
        // marcar el camino
        tree.path(a,b,st,1);        
        tree.path(c,d,st,1);
        // tomar los puntos en comun        
        cout << tree.count(a,b,st) << endl;        
        // limpiar el camino
        tree.path(a,b,st,0);
        tree.path(c,d,st,0);


    }    
}
int main() {
 
    FAST
    int test = 1;
    //cin >> test;
    while (test--) solve();
        
    return 0;
}
